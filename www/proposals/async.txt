WSDL Definition
===============

<definitions name="foo"
    targetNamespace="http://xml.sun.com/ws/foo"
    xmlns:tns="http://xml.sun.com/ws/foo"
    xmlns="http://schemas.xmlsoap.org/wsdl/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/">

  <message name="barRequest">
    <part name="p1" type="xsd:string"/>
    <part name="p2" type="xsd:string"/>
  </message>

  <message name="barResponse">
    <part name="p2" type="xsd:string"/>
    <part name="return" type="xsd:string"/>
  </message>

  <portType name="fooPort">
    <operation name="bar" parameterOrder="p1 p2">
      <input message="tns:barRequest"/>
      <output message="tns:barResponse"/>
    </operation>
  </portType>

  <binding name="fooBinding" type="tns:fooPort">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/>
    <operation name="bar">
      <soap:operation style="rpc"/>
      <input message="tns:barRequest">
        <soap:body use="literal" namespace="http://xml.sun.com/ws/foo" parts="p1 p2"/>
      </input>
      <output message="tns:barResponse">
        <soap:body use="literal" namespace="http://xml.sun.com/ws/foo" parts="p2 return"/>
      </output>
    </operation>
  </binding>

</definitions>


JAX-RPC 1.1 Mapping
===================

The WSDL above maps to the following Java interface using the rules JAX-RPC 1.1:

public interface FooPort extends java.rmi.Remote {
    java.lang.String bar(java.lang.String p1,
        javax.xml.rpc.holders.StringHolder p2)
        throws java.rmi.RemoteException;
}


Proposed Async Mapping
======================

We would generate two additional interfaces as follows:

public interface FooPortAsync extends FooPort {
    // polling version of bar method
    AsyncResponse<BarResponse> startBar(java.lang.String p1,
        java.lang.String p2) throws java.rmi.RemoteException;

    // callback version of bar method
    AsyncResponse<BarResponse> startBar(java.lang.String p1,
        java.lang.String p2, FooPortAsyncHandler h)
        throws java.rmi.RemoteException;
}

public interface FooPortAsyncHandler {
    void endBar(BarResponse br);
    // require one fault handler per method or interface ?
    void handleFault(java.lang.Exception e);
}

where AsyncResponse is a generic class based on JSR 166 as follows

interface AsyncResponse<T> extends Future<T> extends Condition {
}

and BarResponse is an JAXB interface generated for the barResponse
message defined in the WSDL. BarResponse is effectively a wrapper for
all of the output of the method bar.


JAXB Connection
===============

We're going to have to specify the contract between JAX-RPC and JAXB.
JAXB targets schema not WSDL so it seems natural for JAX-RPC to use JAXB
to generate marshallers and unmarshallers for message payloads rather
than messages themselves, i.e. for the contents of a SOAP Header and
Body rather than the actual SOAP Envelope.

For rpc/literal the WSDL types section doesn't actually contain a schema
for the message payload (as would be the case for doc/literal) but its
possible to derive one from the other WSDL constructs. The input to JAXB
in this example would be an XSD synthesized from the WSDL above and
would look something like

<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  elementFormDefault="qualified"
  targetNamespace="http://xml.sun.com/ws/foo">

    <xsd:element name="bar">
      <xsd:complexType>
        <xsd:sequence>
          <xsd:element form="unqualified" name="p1" type="xsd:string"/>
          <xsd:element form="unqualified" name="p2" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>

    <xsd:element name="barResponse">
      <xsd:complexType>
        <xsd:sequence>
          <xsd:element form="unqualified" name="p2" type="xsd:string"/>
          <xsd:element form="unqualified" name="return" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>

</xsd:schema>

Note that the global elements "bar" and "barResponse" are named after
the WSDL operation rather than the WSDL message.  WS-I BP 1.0
requirements R2712 and R2729 clarify the name of the payload root
element for doc/literal and rpc/literal bindings respectively.

The JAXB generated interfaces would be

public interface BarResponse
    extends javax.xml.bind.Element, com.sun.xml.ws.async.BarResponseType
{
}

public interface BarResponseType {
    java.lang.String getP2();
    void setP2(java.lang.String value);
    java.lang.String getReturn();
    void setReturn(java.lang.String value);
}


Usage Examples
==============

Usage 1: Polling with timeout

AsyncResponse<BarResponse> res = port.startBar("hello", "world");

// do something else for a while

BarResponse br = res.get(300, TimeUnit.MILLISECONDS);


Usage 2: Polling until finished

AsyncResponse<BarResponse> res = port.startBar("hello", "world");

while (!res.isDone()) {
  // do something else
}

BarResponse br = res.get();


Usage 3: Polling in a different thread

class ResponseThread extends Thread {
  AsyncResponse<BarResponse> res;
  ResponseThread(AsyncResponse<BarResponse> res) {
    this.res = res;
  }

  public void run() {
    if (res.await(300, TimeUnit.MILLISECONDS) == true) {
      // do something with the result
    }
    else {
      // operation timed out
    }
  }
}

AsyncResponse<BarResponse> res = port.startBar("hello", "world");
Thread responseThread = new ResponseThread(res);
// go on and let the new thread handle the response


Usage 4: Callback

class MyFooHandler implements FooPortAsyncHandler {
  FooHandlerContext fhc;
  public MyFooHandler(FooHandlerContext fhc) {
    this.fhc = fhc;
  }

  public void endBar(BarResponse br) {
    // do something with br
  }
  public void handleFault(Exception e) {
    // do something with e
  }
}

FooHandlerContext fhc = new FooHandlerContext(...);
FooPortAsyncHandler h = new MyFooHandler(fhc);
AsyncResponse<BarResponse> res = port.startBar("hello", "world", h);
// do something
if (!res.isDone()) {
  res.cancel(true);
}


Usage 5: Callback variant

public class AsyncClient implements FooPortAsyncHandler {

  public AsyncClient() {
  }

  public static void main(String[] args) {
    FooPortAsyncHandler h = new AsyncClient();
    AsyncResponse<BarResponse> res = port.startBar("hello", "world", h);
    // do something
    if (res.await(60, TimeUnit.SECONDS)) {
      // carry on, knowing that endBar has been called
    } else {
      res.cancel(true);
    }
  }

  public void endBar(BarResponse br) {
    // do something with br
  }

  public void handleFault(Exception e) {
    // do something with e
  }

}



Application to DII
==================

We can apply the same pattern described above to DII, the result is
similar to the proposal from Sunil if you substitute PollHandler for
AsyncResponse, CallbackHandler for CallAsyncHandler and AsyncResponse
for CallResponse.

public interface CallAsync extends Call {
    // polling versions of invoke methods
    AsyncResponse<CallResponse> startInvoke(
        java.lang.String operationName,
        Object[] params) throws java.rmi.RemoteException;
    AsyncResponse<CallResponse> startInvoke(
        Object[] params) throws java.rmi.RemoteException;
    // do we need async variation of invokeOneWay ?

    // callback version of invoke methods
    AsyncResponse<CallResponse> startInvoke(
        java.lang.String operationName,
        Object[] params,
        CallAsyncHandler h) throws java.rmi.RemoteException;
    AsyncResponse<CallResponse> startInvoke(
        Object[] params,
        CallAsyncHandler h) throws java.rmi.RemoteException;
}

public interface CallAsyncHandler {
    void endCall(CallResponse r);
    void handleFault(java.lang.Exception e);
}

public interface CallResponse {
    java.util.Map getOutputParams();
    java.util.List getOutputValues();
    java.lang.Object getReturnValue();
    QName getParameterTypeByName(String paramName);
    QName getReturnType();
    QName getOperationName();
    QName getPortTypeName();
}

We may want to consider refactoring the Call interfaces to extract
common methods from Call and CallResponse.
