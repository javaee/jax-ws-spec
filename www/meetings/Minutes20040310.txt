Minutes of the JSR 224 F2F meeting on 10, 11 Mar, 2004. Scribes: Russel,
Glen, Bjarne, Doug.

Wed 10th March

9.00am: Roll call, introductions

N	ATG	Jim Frost Y	BEA Systems 	Manoj Cheenath
N	DevelopMentor	Kevin Jones Y	IBM	Russell Butek N	IONA
Technologies PLC 	Daniel Kulp N	Motorola 	Rahul Sharma
N	Nokia	Srividya Natarajan Y	Novell, Inc. 	Bjarne Rasmussen
Y	NTT Data Corp	Toshiyuki Kimura Y	Oracle	Sunil Kunisetty
N	Pramati	Rajiv Shivane N	SAP AG 	Chavdar Baikov
N	SeeBeyond Technology Corp. 	Ugo Corda Y	Sonic	Glen Daniels
R	Sosnoski Software	Dennis Sosnoski Y	Sun	Marc Hadley
R	Sun	Roberto Chinnici Y	Sun	Doug Kohlert N	Tmax
Soft	Changshin Lee N	WebMethods Corporation 	Christopher St.
John

AOB J2EE 1.5 ease-of-use vs JAX-RPC discussion

Approval of 4th March meeting minutes - approved

Spec Schedule

(JCP 2.6 - no community draft (which needs a vote) - an early draft is
just a way to expose early versions to the world.)

early draft - May public draft - Sep proposed final draft - Nov final
spec - Feb 2005

early draft - asynchrony - this is added functionality that might strain
J2EE 1.5 ease-of-use-only statement - DII enhancements - JAX-B
integration (what about SDO?) - Handler framework

public draft - WS-I BP 1.1 - SOAP 1.2 - in line with WSDL 2.0 - no
reason to deal with SOAP 1.2 and WSDL 1.1 unless someone defines a SOAP
1.2 binding - WSDL 2.0 - revisit this mid-year to make sure it's on
target for us to get in - this might strain the J2EE 1.5
ease-of-use-only statement - non-HTTP transports - abstraction of
transport AND protocol - but only define HTTP/SOAP? - versioning and
evolution - need to talk with JAX-B folks - annotations - security

We need to make sure that we distinguish between the existing Call
object and the new Dispatch object when discussing changes/new function.
The existing Call object will be retained only for backward
compatibility - there is no intention of fixing it - any new work will
be on the new Dispatch object.

Break

Joint meeting with JSR 208 EG to discuss integration alignment issues

Does the Normalized Message (NM) belong in JAX-RPC?

Client Server -------- ---------- | JAX-RPC + JAX-B ^ Provider | ---- |
---- | JAX-RPC + NM | JAX-RPC + NM V ---- | ---- | Protocol binding ^
Protocol binding | NM -> serialization | deser -> NM | RPC - SOAP | RPC
- SOAP V SOAP | SOAP

Marc: Want to think about this provider thing a little more

Richard: Two parts - both normalized messages and server dispatch...
might not be bad, tho.

We'd be exposing elements of the programming model which aren't really
"RPC" focused, so is that OK?

Marc: Avoid normative dependence on JBI from JAX-RPC... scheduling, etc.

Russell: jar file problem - don't want to require both...

Sunil: Provider model is somewhat independent of the NM question.

Glen: NM is the bridge between JBI/JAX-RPC, that's what makes it useful.

Sunil: Yes, but we don't necessarily have to go there

Richard writes on the board

Richard: If we do this, we have something which can be a generic SOAP
node (intermediary)

Bjarne: We don't have to deal with normalized messages, we can build
that on top

Bjarne: Generic dispatch - JAX-RPC version would use SOAP message and do
"magic".  208 could convert to normalized form itself.

Richard: NM is abstract - but just because the interface is abstract
doesn't mean we've lost the real information about what it is
underneath.

Marc: We've already done the client side part of this - you hand a
property bag and xml down to the engine, and select a protocolbinding...
maybe we're just doing the server part

Richard: Exactly what I was getting at

Marc: This avoids NM

Glen: This is the same thing as NM in JBI

Marc: Passing in JAXB object is cool

Glen: Could do that either with context properties or via downcasting
the message itself

Marc: I'll sketch something out

ACTION : Marc to put together proposal for a JAX-RPC normalized message,
with some input from Nick

Marc: What about asynchrony on the server side?

Richard: On the server side, not sure I understand the model..

(various): Long running transactions

Richard: We don't need to go there

Marc: OK, dispatch is async on client side, not on server side.

ACTION: Manoj to find out whether JSR181 revision 1.1 will be done in
time for J2EE 1.5

Sunil: MessageContext has no standard properties right now... we could
define some (operation name, WSDL location, etc) to be set by the
container before Handlers.

Marc: Yes, we need these for all kinds of things, we'll get to defining
a bunch of them.


Handler Framework -----------------

Glen: I can componentize handler chains, right?

Richard: Haven't exposed an API for HandlerChain yet, but deployment
should deal with that.

(walking through handler proposal)

Richard: There is some dependency between the deployment info and the
code wrt which headers a Handler deals with.

Marc: Should the HandlerInfo contain a subset of the headers that the
Handler processes?

Richard: Both should be allowed to declare...

Manoj: When we're generating WSDL, we could add header declarations
based on Handlers.

Glen: Too confusing, since Handlers might want optional headers, say,
and there is no way to express that in WSDL

Bjarne: Annotations are better - somewhere in the deployment have a
descriptor that indicates that something should get added to the WSDL.

Sunil : We have to regenerate WSDL if we do this, since the original
might not have this info...

Manoj : Yes, we want to be able to change this stuff at runtime, perhaps
(adding a new handler to a running service)

Sunil: You won't see "infrastructure" headers in the WSDL, just "user"
ones

Richard: getHeaders() on Handler might want to be deprecated, since the
code and the deployment descriptor have to match

Options- 1. Leave everything as is 2. Filter handler - Handler only
invoked if header(s) exist defined by HandlerInfo.getHeaders() 3. Filter
handler based on Handler.getSupportedHeaders() 4. Fitler handler based
on BOTH 2 + 3

Richard : Handlers might want to be restricted from looking at the whole
message (i.e. only security handler gets to see security header)

(discussion of whether the engine needs to look at the message in
between each handler called, to determine whether to call handleFault,
etc)

Glen : Seems like you really don't want the infrastructure to be forced
to make these decisions.  If you deploy a Handler, that is
infrastructure code and should therefore be trusted.

Russell: We need to say that if we decide that.

Glen: +1

Marc: So let's refocus - IBM security guys have a problem with WSS
header being visible. But the spec says it needs to be visible.  Seems
like you need to talk. :)

Richard: let's follow through here, even though there may be arguments
against this stuff.

If the implementation really wants to (modify it's SAAJ implementation
to prevent getting the message from the body object, etc) it can make
things secure.

Richard: Could track the addition/deletion of headers, flags, etc to
make the system well-behaved in terms of being able to dispatch/filter.

Manoj: One way to deal is with a specific type of handler which filters.

Marc: We've drifted a little, we need to talk about how they are
invoked, and we're talking about what they can see when they do get
invoked.  Let's note this and continue.

Back to the options.

Richard: 2 and 4 are almost identical....?

(discussion of HandlerInfo vs. Handler builtins)

Glen: concerned about repeated information (code and handlerinfo)

Marc: What if we specify the relationship between the handlerinfo and
the handler code?

Glen: That might work

(Glen suggests pull this info out from the deployment descriptor)

Sunil: Can't pull this out of 109... this would cause a disjoint.

Russell: We could ask 109 to pull it in v.Next too

Richard: In 109 you can't change the message with Handlers.

Marc: Suggest adding getSupportedHeaders() to Handler, which returns the
QNames the code claims to support.  getHeaders() always returns the
headers in the deployment information. Then the container can decide
what to do with the intersection.

Richard: do we make an explicit statement about what the runtime does?

Marc: Has to be getHeaders() (i.e. HandlerInfo)

Marc: So this is a sanity-checking mechanism.

Richard: Runtime already has access to HandlerInfo, and shouldn't be
calling the method on Handler.... so we only really need one method on
Handler.  Why not leave it as getHeaders() and allow the Handler code to
decide either to return the HandlerInfo list or a list determined by the
code

Resolution - clarify definition of getHeaders() API on Handler to return
the set of headers supported by the Handler developer.  The set of
headers specified in the HandlerInfo deployment descriptor MUST BE a
subset of the set returned by handler.getHeaders(), otherwise a fault
will be thrown at deployment time.  (see Richard's note for more
details)

Confusion as to whether we are using this for mustunderstand resolution
or dispatch.

Glen: If using this for MustUnderstand, we can't support
null==everything

Richard: Let's put off filtering discussion til later

Richard: Other topics - is there a more generic handler than
SOAPHandler, and what about roles?

Glen: "Dynamic understanding" wouldn't work with static understanding...

Richard: But if you process then you have to do rollback....

Glen: OK, don't really need dynamic understanding perhaps.

Richard: It's valid to have a handler deployed which doesn't process any
headers.  So null return from getHeaders() means nothing is understood
by that guy.

(general consensus)

Richard: Can we talk about handlers and roles?

Sunil : Still need to deal with understood headers when the header is
processed by the service endpoint

(general agreement, but moving on to roles discussion)

Richard: Roles don't work very well right now with JAX-RPC or J2EE.

Glen : two issues... 1) If decryption occurs, we now need to run the MU
checks again, 2) if the MU checking requires knowledge of the service
endpoint, you can't always know what the service is without processing
SOAP headers in some cases

(discussion in which the scribe was involved)

ACTION : Marc to ask XMLP about the expected behavior when processing a
header (decryption) causes more MustUnderstand headers to appear in the
message.

Richard: Is this stuff a special case, or are general users dealing with
this stuff?  Maybe we shouldn't deal with this, and let specific
implementations have back doors, etc?

(mumbling of assent)

ISSUE : 109 has the ability to specify soap actor on individual
Handlers... need to flag this.

Sunil : Do we say that the understood headers are never removed?

Marc : Yes, because the SOAP spec talks about removing headers in the
act of relaying.

Richard : We do define intermediaries with these APIs, even though the
spec doesn't mandate it.  As such we'd like to say something about how
removal works.

Glen: So we need a "reinserted" bit, which indicates that a given header
is meant to persist past this node.  At the end of processing for a
given node, before forwarding, it deletes all headers a) targeted at the
node, b) not marked relay="true", and c) not marked "reinserted".

ISSUE : Need to add reinserted boolean to SAAJ SOAPHeaderElement

Marc : do we need a separate ProtocolBinding class for SOAP 1.2?

Richard : Yes, let's qualify the class names.

Discussion of whether we want generic Handler or not

Glen: Why is there a SOAPMessageContext?

Marc: Because that's how you get a SOAPMessage?

Glen: So why isn't there just a getMessage() which casts down?

(discussion)

OK, let's a) deprecate SOAPMessageContext, b) return the
SOAPProtocolBinding from getProtocolBinding() in MessageContext, from
which you can get SOAP-specific stuff.

Sunil: Have to talk about transport at some point.

Discussion of protocol-specific Handlers.  People generally like having
a generic Handler and then protocol-specifc Handlers inherit from that.

Russell: Are we going to have client-side application Handlers?  If so
do they see Java objects, normalized messages, etc...?

(discussion of thread-safe stubs... general opinion that Stubs are not
thread-safe)


Adjourn


Thur 11th March

A continental breakfast will be available from 8.30am.

9am: Roll call

N	ATG	Jim Frost Y	BEA Systems 	Manoj Cheenath
N	DevelopMentor	Kevin Jones Y	IBM	Russell Butek N	IONA
Technologies PLC 	Daniel Kulp N	Motorola 	Rahul Sharma
N	Nokia	Srividya Natarajan Y	Novell, Inc. 	Bjarne Rasmussen
Y	NTT Data Corp	Toshiyuki Kimura Y	Oracle	Sunil Kunisetty
N	Pramati	Rajiv Shivane N	SAP AG 	Chavdar Baikov
N	SeeBeyond Technology Corp. 	Ugo Corda Y	Sonic	Glen Daniels
R	Sosnoski Software	Dennis Sosnoski Y	Sun	Marc Hadley
R	Sun	Roberto Chinnici Y	Sun	Doug Kohlert N	Tmax
Soft	Changshin Lee N	WebMethods Corporation 	Christopher St.
John


Protocol specific fault handling

marc: glen's proposal requires more code generation, merged proposal: -
deprecate SOAPFaultException - new ProtocolDetailsException (marker
class) - SOAP11ProtocolDetailsException, etc. with type-safe
getters/setters - server-side: throw RemoteException with protocol
exception as cause/detail - server-side api to determine protocol over
which fault will be transmitted

discussion about how to set specific protocol detail, e.g. soap fault
code - deployment?

- client can do RemoteException.getCause and cast to particular
exception - SOAPFaultException is basically
SOAP11ProtocolDetailsException

sunil: very similar to old proposal. what happens if protocol exception
doesn't match protocol?

marc: then it's ignored

glen: are we overloading cause?

russel: we're not going to have null pointer exception in cause?

glen: why not? implementation can set this in detail

sunil: need api for getting protocol since endpoint might for instance
be both soap 1.1 and 1.2

glen: axis has single fault for both soap 1.1 and soap 1.2

marc: we can discuss the specific protocol detail exceptions later

glen: don't like "details" in name

russel: agree, just call it ProtocolException

doug: how can we prevent breaking existing code?

russel: what if client tries to catch SOAPFaultException?

glen: flag to enable throwing the SOAPFaultException

marc: current spec doen't say that SOAPFaultException is even thrown on
client

glen: ok to say that people need to change code, since code wasn't
portable anyway

doug: make SOAP11ProtocolDetailsException subclass of
SOAPFaultException?

marc: SOAP11ProtocolDetailsException will *be* SOAPFaultException

russel: won't break many people

marc: need to catch RemoteException and SOAPFaultException in client
anyway

doug: maybe tck has test case that relies on getting SOAPFaultException

manoj: we never throw SOAPFaultException on client (and we pass tck)

issue: need server-side api to determine protocol over which fault will
be transmitted issue: rename to ProtocolException

Asynchrony - Toshiyuki

- motivate need for async, client holds on to http connection in
long-running invocations - describe push and pull style async, key is
use of two http connections - detailed polling implementation: invoke
and get "id" - get result later using "id" - polling drawbacks:
busy-wait (issue 1), more complex client code (issue 2) - issue 1: let
server send poll timing info to client as QoS - issue 2: write a utility
library that deals with QoS - ntt prototype based on axis, benefits: *
significant reduction in client code * allows async invoke using jax-rpc
1.1 apis * three styles of invocation available to clients (sync, async,
poll) * api does not depend on what happens at the transport layer *
server gets to decide QoS - important to include into jax-rpc 2.0

sunil: this implementation is possible using the current dispatch
proposal

bjarne: except defining wire formats for QoS is problematic

all: jax-rpc is only api, not implementation (and not wire protocols)

toshiyuki: want to address server side asynchronous model

marc: this is again an implementation detail

richard: oneway invoke deals with part of this

glen/sunil: invocation may involve multiple invocations, wsdl is
application level semantics

marc: api allows polling 100 times, binding may just poll once,
implementation issue

glen: wsdl extensions in binding, e.g. additional methods in the
endpoint not exposed to application

toshiyuki: need new programming model on server for async

glen: spawn thread before/after handler chain invocation?

marc: jac-rpc should not mandate a particular implementation russel:
effectively async on the provider

toshiyuki: endpoint delivers to jms queue and then returns ok, exposes
polling "get" operation

toshiyuki: want to define schedule/get api in provider interface

bjarne: we'd need to define a wire format for ok message with id

glen: need wsdl binding extension, we'd define a pattern; probably
beyond our scope

sunil: several implementations have this, we use jms correlation id in
soap header

marc: out of scope

all: the place to do this would be oasis


Handler framework cont'd

richard described handler policy:

- return false from handleRequest means handler is done - policy to deal
with wrapping old behavior - handler handler - allow one wrapper rather
than n

glen: visitor; to solve the wrapping problem?

richard: yes, avoid instantiating too many wrappers

glen: interesting mechanism, but solves an implementation problem

marc: wrapping difficult to spec

russel: can we say that if it's old style look in old spec?

glen: can we say that entire handler chain must be either new style or
old style?

russel: no, handler may be coming from different places/vendors that
haven't moved up

sunil: need mechanism for a handler to get access to other handlers

glen: by using the message context

richard: we'd need to determine execution order of policy

richard: can customers write their own handler chains?

marc: yes, but they should adhere to spec rules

marc: do we need new handler to be subclass to be able to distinguish?

sunil: do we need server side api to dynamically set handler chain?

glen: old style deployment description should still be supported

richard: if there are two behaviours i'd prefer not to subclass

marc: create new base class that both handler classes would extend

all: handler policy should go, implementation only

manoj: registration api problematic because client needs to know qname

marc: should stub, call and dispatch all extend some class that has the
handler registry stuff

russel: needs to be on service, not on stub

sunil: but each port might have different handler chain

marc: to get stub with particular handler chain, first set on service,
then to get stub with different handler chain, set again on service. if
service handler chain changes, do previously created stubs' handler
chain also change?

russel: yes

bjarne: no

russel: spec is not clear

marc: problematic

richard: would prefer to deprecate registry api on service, now on
protocol binding

glen: is there on protocol binding per port?

sunil: yes

marc: the protocol binding comes from the service, one per port

sunil: use the old api to set service wide handler chain, use protocol
binding to set per port

bjarne: then stub's handler chain can change without client knowing

marc: stub gets snapshot of handler chain

sunil: on the server-side it is per port

russel: in managed client you can't access handler registry

marc: should we move handler stuff into protocol binding base class?

richard: agree

russel: if our handler is generic then the api is problematic, implies
request/response

marc: handlerInbound/handleOutbound instead?

russel: doesn't help

glen: in axis we had context with three messages:
request/response/current

russel: would like specific rpc handler interface

glen: would like single handler interface to deal with all styles

richard: do we need to be able to set protocol binding

sunil: perhaps, e.g. to allow switching from soap 1.1 to soap 1.2
dynamically

glen: would prefer not to allow that

marc: do we need to move getProtocolBinding to service

russel: yes, and deprecate getHandlerRegistry

marc: use case for setProtocolBinding: when you don't have wsdl and want
to do things dynamically - perhaps set using uri that e.g. represents a
soap 1.1 binding - protocol binding from protocol binding factory

general discussion about whether to put getProtocolBinding on
stub/call/dispatch or service

manoj: stub is problematic because users have to cast it from sei

richard: do we need the concept of a port?

russel: what do programmers do: get service, get port, then get stub?
overly complex

marc: keep easy-to-use getXXPort methods, add getPort?

glen: must have both generic handlers and transport specific handlers

bjarne: service has protocol binding that stub/call/dispatch gets upon
creation, after stub/call/dispatch has api to get the protocol binding

marc: handler chain needs to be on port, not on protocol binding

richard: but we also need to be able to set e.g. soap handlers on
protocol binding

glen: is enc/literal and rpc/doc in protocol binding?

marc: no, that's in stub

glen: need transport, local, and service handlers

sunil: we need to decide what level we want this

bjarne: get rid of port, just give handler api on service and
stub/call/dispatch

russel: perhaps remove "protocol" and just call it binding

manoj: just one handler chain because ordering is very important

russel: this will impact jsr 109

glen: our design center should be that handlers are powerful, that
developers should know what they're doing; we should not try to protect
people from doing harm

marc: provide addPort method on service?

issue: rename ProtocolBinding to Binding issue: do we need to introduce
PortConfig issue: handlers on (i) service, (ii) protocol binding, (iii)
port config, or (iv) stub/call/dispatch issue: where does protocol
binding belong

filtering, masking postponed to afternoon


Lunch

JAX-RPC / JAXB integration JAXB Schedule: Intent is to align the two
schedules, early draft by JavaOne.  Would include schema->Java,
Java->Schema and any other JAXRPC 2.0 requirements

Issue: Portability of generated artifacts (no generation of impl
specific stuff) JAXRPC can create a portable thing.  JAXB generates
implementation specific stuff. JAXB needs to divided into a development
phase and a deployment phase code generation

Resolution: JAXB will generate portable artifacts

Issue: JAXB Roundtripping (Java -> schema -> Java) Do the Java classes
need to be identical or is simply having Identical interfaces
sufficient. example problems: Date -> xsd:date -> Calendar naming rules
(case changes) Generated schema could be generated with annotations to
get back to the original classes Resolution: Roundtripping will be
requirment schema + Java re-mapping is not a reqjuirement, nor is
schema->Java->schema

Issue: Classes vs Interfaces

Legacy code - Java -> schema -> Java does this make sense for beans can
a generated been have 	members that are interfaces and not classes,
this may not be a problem. However, how does serialization work because
we must be able to get back to the original class.

Programming habits - do we want to change how JAXRPC developers program.
 Do we want to make them start using factories etc.  Can we require that
JAXB have an option to generate classes instead of interfaces?
Resolution: JAXB will have an option to generate classes instead of
interfaces?

Containment versus reference was discussed

Issue: Interfaces should be serializable Resolution: JAXB classes will
be serialized as XML.

Issue: Can JAXB work with classes/objects not generated by JAXB
Resolution: JAXB will work on non JAXB generated classes/types as well
as JAXB generated ones.

Issue: Relationship to SDO Resolution: JAXB implementation classes could
be SDO implementation classes JAXB spec is not going to spec any
relationship between SDO and JAXB Alignment is the goal

Issue: Classes vs Interfaces Exceptions Resolution: JAXB could generate
the interface. JAXRPC could generate an exception that implements the
interface

Issue: In WSDL 2.0 what would the name of the exception Resolution: the
name would be the name of the fault.

Issue: Do we need WSDL annotations for Java artifacts expressed in a
WSDL, messages, faults etc. Resolition: TBD

Issue: Disabling data binding at various levels was discussed.
Resolution: TBD

Issue: How dows JAXB bind xsd:any type Resolution: xsd:any type binding
has not yet been defined in JAXB 2.0.

Issue: Schema is used to generate JAXB classes, one part of the schema
can't be mapped, if we then 	generate WSDL from the JAXB classes, can
we have the original schema for the unmappable type be regenerated.
Resolution: Probably not in this release

Issue: Is what JSR 181 metadata going to be sufficient for JAXB.
Resolution: TBD

Issue: Can JAXB handle the entire payload or just a  part Can JAXRPC
generate wrapper schema so that JAXB only deals in payloads?
Serialization/deserialization contexts must be used between JAXRPC and
JAXB namespace to prefix maps id -> object maps Resolution: JAXB will be
able to handle parts.  It is implementation specific how this is to be
done. An implemenation can choose to generate wrapper schema if they
wish Serialization/deserialization context are implementation specific
unless JAXB decides to include it.


Issue: Customizations (custom serializers) Resolution: Not discussed

Issue: JAXB runtime, packaging Resolution: Not discussed

Issue: Dynamic Generation Resolution: Not discussed

Issue Different parser implementations Resolution: This should go away
due to the JAXRPC/JAXB paring.

Issue: Reference resolution for ID/IDREF, attachment references
Resolution: Not discussed

Issue: Versioning and Evolution Resolution: Not discussed

Break

Handlers: Issue: Where do handlers belong? Resolution Don't set handlers
on the stub or dispatch. Handlers get set on the service, portconfig and
protocol binding.

Issue: What does set target endpoint address on the stub do? Resolution:
Changing the target endpoint address on a stub changes the port. Port is
a binding and address.  If you change one, you change the port.  Setting
the endpoint address is equivalent to going back to the service cloning
the port changing and changing the address.  In short, setting the
endpoint interface will leave handlers in place on the stub.


Issue: Filtering handlers: Resolution: Handler filtering is a
implementation specific function. Resolution: JAXRPC will not define how
filtering works.

Issue: Masking: Resolution: Is allowed by an implementation but it is
not invisible.  If a handler tries to access something that it
	should not it should throw a security exception.

Issue: Should we include a HandlerChain class.  If this is true, a
handler chain is responsible for 	maintaining/implementing handler
life cycle on the handlers that it contains.  If you have nested handler
chains and a handler in a nested chain throws a runtime exception, what
gets life cycled, 	just the handler that threw the exception or the
entire nested handler chain.

Resolution: HandlerChains will not be mentioned by the JAXRPC spec.


AI: Marc to write up a proposal on how handlers, services, ports etc.
work. AI: Marc to see if a F2F can be done in June with JAXB, if not
then, July

Adjourn
