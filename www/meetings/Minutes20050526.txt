Minutes for the JSR 224 telcon on 26 May, 2005.

Agenda:

1. Roll call

Marc, Roberto, Doug, Rajiv, Brian, Greg, Chen

2. Approval of draft minutes

https://jsr224.dev.java.net/meetings/Minutes20050519.txt - Approved

2. Agenda bashing and AOB

None

3. J2SE server APIs

We'll run through the issues Roberto posted to the list. Want to get this addressed before we publish out Public Review Draft

(1) Setting the service name for a Provider

Unlike the case of a strongly-typed implementor that uses JSR-181
annotations, if the implementor is a Provider, there is no service/port
name information associated with it. In general, one of the appealing
things about providers is that they can potentially support endpoints
of different types (e.g. in the case of a gateway provider), so we want
to avoid requiring some special annotation to be placed on them.

Candidate solutions:

 (1.a) Add a property bag to Endpoint, i.e. two methods
             Map<String,Object> getProperties();
             void setProperties(Map<String,Object>);
       , and two standard properties:
        "javax.xml.ws.endpoint.serviceName" of type
javax.xml.namespace.QName
        "java.xml.ws.endpoint.portName" of type String
        (or should it be QName for consistency with the other APIs that
         accept a port parameter? also, do we really need the
         setProperties method?)

 (1.b) Add service name and port name properties to Endpoint:
             QName getServiceName();
             void setServiceName(QName serviceName);
             String getPortName();
             void setPortName(String portName);

 (1.c) Restrict the metadata used in conjunction with providers so
       that exactly one WSDL contains a service definition, which
       in turn contains exactly one port compatible with the binding
       specified when the endpoint was created.
       
Discussion:

Greg: Is there a presumption that there's only one WSDL ? Provider is flexible and a single instance could support multiple.
Marc: Perhaps make a choice now and add a note to the spec asking for input on this.
Marc: Is this just problem for WSDL 2.0 where a service is tied to single interface.
Greg: Question is whether its a single service in the singleton sense, might be useful to allow a single Provider to multiplex multiple services.
Roberto: Perhaps allow this and then just return a 404 from uri?wsdl.
Greg: Similar to Axis which does allow this, would be good to get feedback from someone on that team.

Decided to do (1.a) for now.


(2) Accessing the MessageContext

Currently, an implementor has no access to the MessageContext for
an invocation it is serving, unless it implements the Provider
interface, that is. By the way, technically, it's not the MessageContext
but a map that contains only the APPLICATION-visible properties in
the message context.

Candidate solutions:

  (2.a) Add the following method to Endpoint:
              Map<String, Object> getRequestContext();

  (2.b) Make the request context accessible via a threadlocal. E.g.
              public abstract class WebServiceContext {
                  public static Map<String, Object> getRequestContext() {
                      // ...
                  }
              }

        Then all the application does has to do is to invoke
              WebServiceContext.getRequestContext()
        anywhere in its code.

As an added bonus, if we went with (2.b), we could remove the context
parameter from Provider.invoke.

Discussion:

Greg: Is this expected to work the same in J2EE and J2SE ?
Roberto: Normally the case modulo some security restrictions.
Greg: We've run into problems with async and would prefer to avoid thread-local.
Marc: couldn't we do something with context injection ?
Roberto: could possibly define a WSContext interface that has a getContext method to return the message context. The WSContext impl class would be responsible for making the necessary magic happen.
Roberto: Could we use the @resource annotation from JSR250
Rajiv: Possibly but not currently planned for inclusion in Mustang - might raise expectations that this would work elsewhere. Need to talk with J2SE team.

ACTION: Rajiv to consult with J2SE team about this.

(3) Alternate implementation pluggability mechanism

The current proposal uses the XYZFactory.newInstance() pattern. Although
this pattern has a long history, it's by no means perfect. Also, many
J2SE APIs use a different one. Instead of placing most of the APIs in an
interface X and having a separate abstract factory class XFactory with
a static newInstance() method, they make the API class X into an
abstract class, then define static factory methods on it. These factory
methods delegate the creation of the actual instance to a XProvider
object in some other package (usually one with "spi" in the name).

In the case of endpoint, the latter approach would look like this:

public abstract class Endpoint {

  // factory methods
  public static Endpoint create(java.net.URI bindingId, Object
implementation);
  public static Endpoint publish(String address, Object implementation);

  // all other endpoint methods follow:
  public abstract Binding getBinding();
  public abstract Object getImplementor();
  public abstract void publish(String address);
  public abstract void publish(Object serverContext);
  public abstract void stop();
  public abstract boolean isPublished();
  public abstract List<javax.xml.transform.Source> getMetadata();
  public abstract void setMetadata(List<javax.xml.transform.Source>
metadata);
  public abstract java.util.List<javax.jws.handler.Handler>
getHandlerChain();
  public abstract void
setHandlerChain(java.util.List<javax.jws.handler.Handler> chain);
}

The implementation of the static factory methods would delegate to
a new class, javax.xml.ws.spi.EndpointProvider:

public abstract class EndpointProvider {
  public abstract Endpoint create(java.net.URI bindingId, Object
implementation);
}

An endpoint provider would be located using an algorithm similar
to that used today to locate the EndpointFactory implementation,
i.e.:
  - look at the javax.xml.ws.spi.EndpointProvider system property first;
  - then look at the $java.home/lib/jaxws.properties file, if any;
  - then look for META-INF/services/javax.xml.ws.spi.EndpointProvider;
  - finally, load an implementation-specific default provider.

Let's contrast the two approaches as seen by the developer. First using
the factory: (3.1)

  FooImpl foo = new FooImpl();
  EndpointFactory factory = EndpointFactory.newInstance();
  Endpoint endpoint = factory.createEndpoint(
                       SOAPBinding.SOAP11HTTP_BINDING,
                       foo);

Then the other one, which we'll call the "provider" approach: (3.2)

  FooImpl foo = new FooImpl();
  Endpoint endpoint = Endpoint.create(
                          SOAPBinding.SOAP11HTTP_BINDING,
                          foo);

IMHO, this code looks cleaner. Here's the question for you: Do you
prefer staying with a factory (3.1) or going with a provider (3.2)?

If you prefer (3.2), what about the Service/ServiceFactory pair?
Should we keep it as-is or try to refactor it to be more consistent
and use the provider pattern?

Discussion:

Marc: should use same model for ServiceFactory/Service
Roberto: Service cases tricker due to generated service implementations but not impossible.
Roberto: might also be possible to merge providers for endpoint and service since these are typically closely linked.

No strong preference expressed for either approach. Will continue to investigate what the Service/ServiceFactory would look like. Can do this after public review since its not so major.

Next telcon on 9th June. Will have full proposal for Endpoint then. Can add preliminary annotation too but then reconcile with JSR 181 post public review.